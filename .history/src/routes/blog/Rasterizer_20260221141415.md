---
title: Implementing a Simple Rasterizer
date: 'February 21, 2025'
description: Discussion and implementation of a simple rasterizer.
---

# Introduction

For our first assignment in CS184, we are told to build a simple rasterizer, with features such as drawing triangles, supersampling, and texture mapping with antialiasing.

This post will detail my journey through this project, talking about implementation details and my thought process behind them.

# Drawing Single-Coloured Triangles

The first problem we have to tackle is drawing single-coloured triangles. To do this, we rasterize triangles as follows:
- First, we construct a bounding box. This can be done by taking the minimum and maximum $x$ and $y$ components of our given points.
- Next, we iterate through each pixel inside of this bounding box. For each pixel, we can then determine whether or not it is "inside" our triangle. If it is, we colour the pixel. Otherwise, we don't.

We also note that it's important for our vertices to have a consistent winding order; this is to ensure that our point-in-triangle check works for any triangle.

## Initial Implementation
Initially, we constructed our bounding box as follows:
```cpp
float min_x = floor(std::min({ x0, x1, x2 }));
float max_x = ceil(std::max({ x0, x1, x2 }));
float min_y = floor(std::min({ y0, y1, y2 }));
float max_y = ceil(std::max({ y0, y1, y2 }));
```

Then, in order to construct our triangle edges, we defined three `Vector3D()` structs and computed the cross-product to ensure that they are in a consistent winding order (in this case, clockwise):
```cpp
Vector3D p0(x0, y0, 0); 
Vector3D p1(x1, y1, 0); 
Vector3D p2(x2, y2, 0);
if (cross(p1 - p0, p2 - p0).z > 0) { 
    swap(p1, p2); 
}

Vector3D z(0, 0, 1);
```

Now, we iterate through our bounding box. Initially, we calculated the edges for our triangle in each iteration, and their corresponding normals. Then, we tested to see if a point was inside the edge or not using the following check:
```cpp
(dot(p - p1, n0) <= 0) && (dot(p - p2, n1) <= 0) && (dot(p - p0, n2) <= 0)
```

If this was true, we filled in the pixel. Else, we didn't. Running this, we see that we get the following result:
![Naïve Implementation on basic/test4.svg](/blog/ggh/fig_1.svg "Figure 1: Naïve Implementation on basic/test4.svg")