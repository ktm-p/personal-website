---
title: Implementing a Simple Rasterizer
date: 'February 21, 2025'
description: Discussion and implementation of a simple rasterizer.
---

# Introduction

For our first assignment in CS184, we are told to build a simple rasterizer, with features such as drawing triangles, supersampling, and texture mapping with antialiasing.

This post will detail my journey through this project, talking about implementation details and my thought process behind them.

# Drawing Single-Coloured Triangles

The first problem we have to tackle is drawing single-coloured triangles. To do this, we rasterize triangles as follows:
- First, we construct a bounding box. This can be done by taking the minimum and maximum $x$ and $y$ components of our given points.
- Next, we iterate through each pixel inside of this bounding box. For each pixel, we can then determine whether or not it is "inside" our triangle. If it is, we colour the pixel. Otherwise, we don't.

We also note that it's important for our vertices to have a consistent winding order; this is to ensure that our point-in-triangle check works for any triangle.

## Initial Implementation
Initially, we constructed our bounding box as follows:
```cpp
float min_x = floor(std::min({ x0, x1, x2 }));
float max_x = ceil(std::max({ x0, x1, x2 }));
float min_y = floor(std::min({ y0, y1, y2 }));
float max_y = ceil(std::max({ y0, y1, y2 }));
```

Then, in order to construct our triangle edges, we defined three `Vector3D()` structs and computed the cross-product to ensure that they are in a consistent winding order (in this case, clockwise):
```cpp
Vector3D p0(x0, y0, 0); 
Vector3D p1(x1, y1, 0); 
Vector3D p2(x2, y2, 0);
if (cross(p1 - p0, p2 - p0).z > 0) { 
    swap(p1, p2); 
}

Vector3D z(0, 0, 1);
```

Now, we iterate through our bounding box. Initially, we calculated the edges for our triangle in each iteration, and their corresponding normals. Then, we tested to see if a point was inside the edge or not using the following check:
```cpp
(dot(p - p1, n0) <= 0) && (dot(p - p2, n1) <= 0) && (dot(p - p0, n2) <= 0)
```

If this was true, we filled in the pixel. Else, we didn't. Running this, we see that we get the following result:

![Na誰ve Implementation on basic/test4.svg](/blog/rasterizer/1/fig_1.png "Figure 1: Na誰ve Implementation on basic/test4.svg")

## Optimizations
### Moving Repeated Operations Out of Loops
The first thing I noticed was that calculating the edges and their normals didn't have to be done inside of our loop each time. As such, I moved them out of the loop. This provided an approximately 2x speedup.

### Direct Edge Computations
After further pondering, I realised that there was another way to speed up my implementation. With the current implementation, I had to calculate the difference between our points three times, and then call the dot product thrice to ensure that the point lies inside our triangle.

Instead however, I could simply compute the edge function directly, and use that in our computations. More concretely, we note that an edge function is simply the following:

$$
\begin{equation*}
    E(x, y) = Ax + By + C
\end{equation*}
$$

And we note that to move across the bounding box, we just have to increment $A$ and $B$. So, we can use the edge functions directly as follows:
```cpp
float A0 = y1 - y0;
float B0 = x0 - x1;
float C0 = x1*y0 - x0*y1;

float A1 = y2 - y1;
float B1 = x1 - x2;
float C1 = x2*y1 - x1*y2;

float A2 = y0 - y2;
float B2 = x2 - x0;
float C2 = x0*y2 - x2*y0;
```

Then, we calculate the edge for the first pixel in our bounding box, and inside our loop, we simply increment $A$ and $B$ appropriately to move across the area. Furthermore, instead of having to call the `dot()` function, we can directly check whether or not our point is valid using the following:
```cpp
if (w0 <= 0 && w1 <= 0 && w2 <= 0) {
    fill_pixel(x, y, color);
}
```

This provided an even larger speedup (of around 3x from the na誰ve implementation).

Below is a table to show the result while running our implementations on `basic/test4.svg`:

Implementation | Time Elapsed (s)
--- | ---
Na誰ve | 0.0005514
Moved Operations | 0.0003070
Direct Edge Computations | 0.0001788

# Antialiasing by Supersampling

# Transformations
For this task, we have to implement the following three transformations:
1. Translation
2. Scaling
3. Rotation

We do this by implementing the appropriate matrices. More concretely, for translations, we would need the following matrix:

$$
\begin{bmatrix}
    1 & 0 & dx \\
    0 & 1 & dy \\
    0 & 0 & 1
\end{bmatrix}
$$

For scaling, we would use this:
$$
\begin{bmatrix}
    sx & 0 & 0 \\
    0 & sy & 0 \\
    0 & 0 & 1
\end{bmatrix}
$$

And for rotations, we first note that since the angle is in degrees, we will have to convert it to radians by calculating $\theta_r = (\theta_d * \pi)/180$. Then, we use the following matrix:

$$
\begin{bmatrix}
\cos(\theta_r) & -\sin(\theta_r) & 0 \\
\sin(\theta_r) & \cos(\theta_r) & 0 \\
0 & 0 & 1
\end{bmatrix}
$$

Now, with these functions implemented, we now see that `transforms/robot.svg` renders correctly:

![transforms/robot.svg](/blog/rasterizer/3/fig_1.png "Figure 1: Default Robot")

And using these functions, we can make it look like the robot is praising the sun:

![transforms/my_robot.svg](/blog/rasterizer/3/fig_2.png "Figure 2: Robot Praising the Sun.")

Here, we created this transformation by applying a 45-degree rotation to its right arm, and a 315-degree rotation to the other arm.
